{"name":"How To JavaScript","tagline":"Things I wish I knew out of the gate.","body":"#Module 0: Javascript Functions\r\n---\r\n\r\n JavaScript has no relation to Java, it simply piggy backed off the popularity of Java during the 90's. The great thing about JavaScript (and most object oriented languages) is that the language skills you develop while writing code end up transcending language barriers. You can use the object-oriented abstraction and apply it to other languages such as Java, JavaScript, C#, C++, Python, PHP, Ruby and Objective-C for example.\r\n \r\nIn JavaScript, functions are the primary work horses of the language. They are roughly equivalent to **methods** in Java. Functions in JS are actually **Function Objects**. When you declare a function like this: \r\n\r\n```js\r\n// a. function declaration\r\nvar sum = function(a,b) {\r\n\treturn a+b;\r\n};\r\n// b. function expression (equivalent to a.)\r\nfunction sum(a,b) {\r\n\treturn a+b;\r\n}\r\n```\r\nYou're actually creating an object of type Function. Your new function,  `sum`, is a Function Object. All Objects in JS have what is called a **prototype** object. Formally, JS implements **prototypal inheritance**; meaning when you create a Object, you inherit all of the functions and properties defined in the **prototypal chain** describing that Object. \r\n\r\n```js\r\n// sum --> Function.prototype --> Object.prototype --> null\r\n// null represents the end of the prototypal chain.\r\n```\r\n\r\nBecause you've created `sum`, which has the type *Function*, you now inherit all of the methods and properties defined on Function's prototypal chain. This includes Object.prototype because Function inherits from Object.  For example:\r\n\r\n```js\r\nsum.length \r\n// outputs 2 - The length property specifies the number of arguments expected by the function. Its defined on Function.prototype\r\nsum.hasOwnProperty()\r\n// outputs false - hasOwnProperty is defined in Object.prototype. You have access to it because sum inherits from Object.prototype\r\n```\r\nWe won't be dealing with the prototypes because they require some experience to leverage.\r\n\r\n###Task 1: write a couple functions\r\n---\r\n\r\n1. Open a new tab in your browser and navigate to the URL `http://127.0.0.1:3000/intern`. You should land on the page that says, \"Hello, Costco Intern!\"\r\n\r\n2. Go into the folder structure **CostcoInternshipJS** and find `intern.js` here: `~\\Desktop\\CostcoInternshipJS\\js\\intern.js`. Also, find  `intern.html` here: `~\\Desktop\\CostcoInternshipJS\\views\\intern.html`. Open these in your favorite text editor. I love *Sublime Text* and *Notepad++*. You can easily google and get one of these editors.\r\n\r\n3.   Below the comments in `intern.js`, define a couple functions that\r\n\t\r\n\t**a.** Sum a series. Write a function that takes a single argument, an integer **n**, and successively sums the series of numbers (beginning with 0) up until **n**. \r\n\t```js\r\n\t// example output: sum(5) = 0+1+2+3+4+5 = 15\r\n\t```\r\n\t\t\r\n\t**b.** Sum only odd numbers. Write a function that takes a single argument, an integer **n**, and successively sums the odd series of numbers (beginnign with 0) up until **n**.\r\n\t```js\r\n\t// example output: sum(5) = 0+1+2+3+4+5 = 9\r\n\t```\r\n\t\r\n4. Test your functions by refreshing the page in your browser (url is `http://127.0.0.1:3000/intern`). Hit F12 in Google Chrome. This opens the Chrome Developer Tools. Now press `Ctrl+P` and type `intern.js`. Select this file and see your new functions defined in the interpreter. If the `console` (a place to type and call code) isn't open, in the top right, click `open drawer` and the `console` should appear. Type the name of your function and a give it a parameter:\r\n\r\n\t```js\r\n\tkurtsSum(5) // = 15\r\n\t```\r\n\t\r\n###Task 2: move your functions into their own namespace\r\n---\r\n\r\nA namespace collision happens when a script happens to have the same name for an Object that a different script that you've loaded has.\r\n\r\n```js\r\n// from script1.js\r\nvar work = function() { \r\n\t// do some work\r\n}\r\n\r\n// from script2.js\r\nvar work = function() {\r\n\t// do some work\r\n}\r\n\r\n// namespace collision of the Function Object work between script1.js and script2.js. The interpreter may pick the wrong function when you call work();\r\n```\r\nNamespace collisions are a real hazard in a modern web application. We can limit these potential hazards by giving a unique namespace to a cohesive body of work. This effectively becomes a **module**. Costco's implementation of a modular pattern in its mobile project not only stops namespace collision but increases portability, readability, and gives a logical structure to a body of work.\r\n\r\n```js\r\nvar SumModule = {\r\n\tsumOfSeries : function(n) {\r\n\t\t// sum the series 0..n\r\n\t},\r\n\tsumOddNumbers : function(n) {\r\n\t\t// sum the odd series 0..n\r\n\t}\r\n}\r\n```\r\nThis represents a **object literal** module pattern. We can now call our functions like this:\r\n\r\n```js\r\nSumModule.sumOfSeries(5) // outputs 15\r\n```\r\nThis is a logical structure for a module that has the functionality of summing a series of numbers in different ways.  The `{}` defines an Object. You can define properties on this Object. You can access these properties by using the reference `SumModule` and period `.`, followed by the name of the property you'd like to access.\r\n\r\n1. Move your functions into a object literal module with a unique namespace.\r\n\r\n2. In the Chrome Dev Tools, call your functions using the module that you made.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}